#!/bin/bash

VERSION="2025-08-19.2"
IMAGE_NAME="claucker"

# Cleanup function for trap
cleanup() {
    [ -n "$BUILD_DIR" ] && [ -d "$BUILD_DIR" ] && rm -rf "$BUILD_DIR"
    [ -n "$SSH_TEMP_DIR" ] && [ -d "$SSH_TEMP_DIR" ] && rm -rf "$SSH_TEMP_DIR"
}
trap cleanup EXIT

print_usage() {
    echo "Usage: $(basename "$0") [OPTIONS] [CLAUDE_CODE_ARGS]"
    echo ""
    echo "Options:"
    echo "  --build           Force complete rebuild of Docker image (--no-cache)"
    echo "  --api-key KEY     Set Anthropic API key"
    echo "  --minimal         Use minimal tool set (faster, smaller image)"
    echo "  --tools TOOLS     Install additional tools (comma-separated, e.g., 'go,glab')"
    echo "  --no-yolo         Disable --dangerously-skip-permissions (cautious mode)"
    echo "  --no-ssh-agent    Disable SSH agent forwarding"
    echo "  --debug           Debug mode: drop to bash shell in container"
    echo "  --help            Show this help message"
    echo ""
    echo "Examples:"
    echo "  $(basename "$0")                            # Run Claude Code (YOLO mode by default)"
    echo "  $(basename "$0") --minimal                  # Run with minimal tools only"
    echo "  $(basename "$0") --tools \"go,glab\"          # Add Go and GitLab CLI"
    echo "  $(basename "$0") --no-yolo                  # Run with permission prompts"
    echo "  $(basename "$0") --api-key sk-ant-...       # Run with API key"
    echo "  $(basename "$0") --debug                    # Debug mode"
    echo "  $(basename "$0") \"Help me with this code\"   # Pass prompt to Claude Code"
}

# Function to create Dockerfile content
create_dockerfile() {
    local minimal_mode="${1:-false}"
    local extra_tools="${2:-}"
    
    cat <<'DOCKERFILE'
FROM ubuntu:24.04

ENV DEBIAN_FRONTEND=noninteractive
ENV TZ=UTC

# Layer 1: System dependencies (rarely changes)
RUN apt-get update && apt-get install -y \
    curl \
    wget \
    git \
    make \
    build-essential \
    ca-certificates \
    gnupg \
    openssh-client \
    sudo \
    # Playwright dependencies for headless browsers (Ubuntu 24.04)
    libglib2.0-0t64 \
    libnss3 \
    libnspr4 \
    libatk1.0-0t64 \
    libatk-bridge2.0-0t64 \
    libcups2t64 \
    libdrm2 \
    libdbus-1-3 \
    libatspi2.0-0t64 \
    libx11-6 \
    libxcomposite1 \
    libxdamage1 \
    libxext6 \
    libxfixes3 \
    libxrandr2 \
    libgbm1 \
    libxcb1 \
    libxkbcommon0 \
    libpango-1.0-0 \
    libcairo2 \
    libasound2t64 \
    && rm -rf /var/lib/apt/lists/*

# Layer 2: Install mise (changes occasionally)
ENV MISE_DATA_DIR="/mise"
ENV MISE_CONFIG_DIR="/mise"
ENV MISE_CACHE_DIR="/mise/cache"
ENV MISE_FETCH_REMOTE_VERSIONS_TIMEOUT=20
ENV PATH="/mise/shims:/usr/local/bin:$PATH"
ENV MISE_PYTHON_COMPILE=false
# Set Rust installation paths to be accessible by all users
ENV CARGO_HOME="/opt/cargo"
ENV RUSTUP_HOME="/opt/rustup"
ENV PATH="$CARGO_HOME/bin:$PATH"
ARG GITHUB_TOKEN
ENV GITHUB_TOKEN=$GITHUB_TOKEN

RUN curl -fsSL https://mise.run | sh && \
    mv /root/.local/bin/mise /usr/local/bin && \
    echo 'eval "$(mise activate bash)"' >> /etc/bash.bashrc && \
    /usr/local/bin/mise settings set python.compile false && \
    /usr/local/bin/mise settings set trusted_config_paths '/' && \
    /usr/local/bin/mise --version && \
    mkdir -p /opt/cargo /opt/rustup && \
    chmod -R 755 /opt/cargo /opt/rustup

# Layer 3: Core tools - minimal or recommended based on flag
DOCKERFILE

    # Add the appropriate mise configuration based on mode
    if [ "$minimal_mode" = "true" ]; then
        cat <<'DOCKERFILE'
# Minimal tools installation
RUN /usr/local/bin/mise use -g \
    node@22 \
    python@3.13 \
    "npm:@anthropic-ai/claude-code" \
    pnpm \
    uv \
    ripgrep \
    jq && \
    /usr/local/bin/mise install
DOCKERFILE
    else
        cat <<'DOCKERFILE'
# Recommended tools installation - base runtimes
RUN /usr/local/bin/mise use -g \
    node@22 \
    python@3.13 \
    rust \
    "npm:@anthropic-ai/claude-code" \
    pnpm && \
    /usr/local/bin/mise install

# Python tools
RUN /usr/local/bin/mise use -g \
    uv \
    ruff && \
    /usr/local/bin/mise install

# CLI utilities
RUN /usr/local/bin/mise use -g \
    ripgrep \
    fd \
    jq \
    yq && \
    /usr/local/bin/mise install

# Cloud/Infrastructure tools
RUN /usr/local/bin/mise use -g \
    gh \
    terraform \
    kubectl \
    awscli \
    azure-cli && \
    /usr/local/bin/mise install

# Code quality tools
RUN /usr/local/bin/mise use -g \
    shellcheck \
    hadolint && \
    /usr/local/bin/mise install
DOCKERFILE
    fi

    # Layer 4: Extra tools (if specified)
    if [ -n "$extra_tools" ]; then
        cat <<DOCKERFILE

# Layer 4: User-specified additional tools
RUN for tool in ${extra_tools//,/ }; do \
        /usr/local/bin/mise use -g \$tool; \
    done && \
    /usr/local/bin/mise install
DOCKERFILE
    fi

    # Continue with the rest of the Dockerfile
    cat <<'DOCKERFILE'

# Note: sudo in container provides elevated privileges within container only,
# not on host system due to --cap-drop ALL and namespace isolation
RUN echo "ubuntu ALL=(ALL) NOPASSWD:ALL" >> /etc/sudoers

# Fix permissions for pnpm (mise installs it with restrictive 711 permissions)
RUN if [ -d /mise/installs/pnpm ]; then chmod -R 755 /mise/installs/pnpm/; fi

# Make /home/ubuntu world-writable so any UID can use it
RUN chmod 777 /home/ubuntu && \
    mkdir -p /home/ubuntu/.claude && \
    chmod 777 /home/ubuntu/.claude

# Ensure mise tools are available in PATH for all shells
ENV BASH_ENV=/etc/bash.bashrc
ENV PATH="/mise/shims:/home/ubuntu/.local/bin:$PATH"

USER ubuntu
WORKDIR /workspace

CMD ["claude"]
DOCKERFILE
}

# Function to detect SSH agent socket location based on platform
detect_ssh_agent_socket() {
    if [ -z "$SSH_AUTH_SOCK" ]; then
        echo ""
        return
    fi
    
    # Check the operating system
    case "$OSTYPE" in
        linux-gnu*)
            # Linux: Use the standard SSH_AUTH_SOCK
            echo "$SSH_AUTH_SOCK"
            ;;
        darwin*)
            # macOS: Check for Docker Desktop's special socket
            if [ -S "/run/host-services/ssh-auth.sock" ]; then
                # Docker Desktop 4.24+ location
                echo "/run/host-services/ssh-auth.sock"
            elif [ -S "$HOME/.docker/run/host-services/ssh-auth.sock" ]; then
                # Older Docker Desktop location
                echo "$HOME/.docker/run/host-services/ssh-auth.sock"
            else
                # Fall back to standard socket (might not work with Docker Desktop)
                echo "$SSH_AUTH_SOCK"
            fi
            ;;
        msys*|cygwin*|win32)
            # Windows/WSL: Check for WSL environment variables
            if [ -n "$WSL_DISTRO_NAME" ] || [ -n "$WSL_INTEROP" ]; then
                # We're in WSL
                echo "$SSH_AUTH_SOCK"
            else
                echo ""
            fi
            ;;
        *)
            # Unknown OS, try the standard socket
            echo "$SSH_AUTH_SOCK"
            ;;
    esac
}

# Load config files (project overrides global)
[ -f "$HOME/.claucker/config" ] && source "$HOME/.claucker/config"
[ -f "./.claucker" ] && source "./.claucker"

# Parse arguments (command line overrides config files)
BUILD_IMAGE=false
DEBUG_MODE=false
USE_YOLO="${CLAUCKER_USE_YOLO:-true}"  # Default to YOLO mode
USE_SSH_AGENT="${CLAUCKER_USE_SSH_AGENT:-true}"  # Default to enabling SSH agent
MINIMAL_MODE="${CLAUCKER_MINIMAL:-false}"  # Default to recommended tools
EXTRA_TOOLS="${CLAUCKER_TOOLS:-}"  # Additional tools to install
API_KEY="${CLAUCKER_API_KEY:-}"
CLAUDE_ARGS=()

while [[ $# -gt 0 ]]; do
    case $1 in
        --build)
            BUILD_IMAGE=true
            shift
            ;;
        --api-key)
            API_KEY="$2"
            shift 2
            ;;
        --minimal)
            MINIMAL_MODE=true
            shift
            ;;
        --tools)
            EXTRA_TOOLS="$2"
            shift 2
            ;;
        --no-yolo)
            USE_YOLO=false
            shift
            ;;
        --no-ssh-agent)
            USE_SSH_AGENT=false
            shift
            ;;
        --debug)
            DEBUG_MODE=true
            shift
            ;;
        --help)
            print_usage
            exit 0
            ;;
        --version)
            echo "claucker version $VERSION"
            exit 0
            ;;
        *)
            CLAUDE_ARGS=("$@")
            break
            ;;
    esac
done

# Force rebuild with --no-cache when --build flag is used
# This ensures fresh tools and clean environment
DOCKER_BUILD_OPTS=""
if [ "$BUILD_IMAGE" = true ]; then
    DOCKER_BUILD_OPTS="--no-cache"
    echo "Forcing complete image rebuild with --no-cache for fresh environment..."
fi

# Build or rebuild image if requested or if image doesn't exist
if [ "$BUILD_IMAGE" = true ] || ! docker image inspect "$IMAGE_NAME" &>/dev/null; then
    echo "Building Docker image..."
    
    # Create temp directory for build context
    BUILD_DIR=$(mktemp -d -t claucker-XXXXXX)
    
    # Write Dockerfile to temp directory
    create_dockerfile "$MINIMAL_MODE" "$EXTRA_TOOLS" > "$BUILD_DIR/Dockerfile"
    
    # Build the image (pass GitHub token if available for rate limits)
    if [ -n "$GITHUB_TOKEN" ]; then
        if ! docker build $DOCKER_BUILD_OPTS --build-arg GITHUB_TOKEN="$GITHUB_TOKEN" -t "$IMAGE_NAME" "$BUILD_DIR"; then
            echo "Failed to build Docker image"
            exit 1
        fi
    else
        if ! docker build $DOCKER_BUILD_OPTS -t "$IMAGE_NAME" "$BUILD_DIR"; then
            echo "Failed to build Docker image"
            exit 1
        fi
    fi
    
    echo "Docker image built successfully!"
fi

# Get project name from current directory
PROJECT_NAME="$(basename "$(pwd)")"

# Generate unique container name with timestamp
TIMESTAMP=$(date +%s)
CONTAINER_NAME="claucker-${PROJECT_NAME}-${TIMESTAMP}"

# Debug mode: show minimal useful info
if [ "$DEBUG_MODE" = true ]; then
    echo "=== Debug Mode ==="
    echo "Container: $CONTAINER_NAME"
    echo "Project: $PROJECT_NAME"
    echo "Host directory: $(pwd)"
    [ -n "$ANTHROPIC_API_KEY" ] && echo "API key: Set via environment" || [ -n "$API_KEY" ] && echo "API key: Set via --api-key" || echo "API key: Not set"
    
    # Check SSH agent
    if [ "$USE_SSH_AGENT" = true ]; then
        SSH_SOCKET=$(detect_ssh_agent_socket)
        if [ -n "$SSH_SOCKET" ]; then
            echo "SSH agent: Available at $SSH_SOCKET"
        else
            echo "SSH agent: Not available"
        fi
    else
        echo "SSH agent: Disabled"
    fi
    echo ""
fi

# Build Docker options
DOCKER_OPTS=(
    --name "$CONTAINER_NAME"
    --rm
    -it
    --user "$(id -u):$(id -g)"
    -v "$(pwd):/workspace/$PROJECT_NAME"
    -w "/workspace/$PROJECT_NAME"
    -e "HOME=/home/ubuntu"
    -e "USER=ubuntu"
    -e "CLAUDE_HOME=/home/ubuntu"
    -e "CLAUDE_PROJECT_NAME=$PROJECT_NAME"
    --cap-drop ALL
)

# Use host network on Linux (doesn't work properly on Mac/Windows anyway)
if [[ "$OSTYPE" == "linux-gnu"* ]]; then
    DOCKER_OPTS+=(--network host)
fi

# Pass API key
if [ -n "$API_KEY" ]; then
    DOCKER_OPTS+=(-e "ANTHROPIC_API_KEY=$API_KEY")
elif [ -n "$ANTHROPIC_API_KEY" ]; then
    DOCKER_OPTS+=(-e "ANTHROPIC_API_KEY=$ANTHROPIC_API_KEY")
fi

# Extract Git configuration for proper commit attribution
GIT_USER_NAME=$(git config user.name 2>/dev/null || echo "${USER:-$(whoami)}")
GIT_USER_EMAIL=$(git config user.email 2>/dev/null || true)

# Pass Git author information to container
if [ -n "$GIT_USER_NAME" ]; then
    DOCKER_OPTS+=(
        -e "GIT_AUTHOR_NAME=$GIT_USER_NAME"
        -e "GIT_COMMITTER_NAME=$GIT_USER_NAME"
    )
fi

if [ -n "$GIT_USER_EMAIL" ]; then
    DOCKER_OPTS+=(
        -e "GIT_AUTHOR_EMAIL=$GIT_USER_EMAIL"
        -e "GIT_COMMITTER_EMAIL=$GIT_USER_EMAIL"
    )
else
    echo "Warning: Git user.email not configured. Commits may not have proper attribution."
fi

# SSH Agent Forwarding
if [ "$USE_SSH_AGENT" = true ]; then
    SSH_SOCKET=$(detect_ssh_agent_socket)
    
    if [ -n "$SSH_SOCKET" ] && [ -S "$SSH_SOCKET" ]; then
        # Platform-specific socket mounting
        case "$OSTYPE" in
            darwin*)
                # macOS: Check if using Docker Desktop special socket
                if [[ "$SSH_SOCKET" == */host-services/ssh-auth.sock ]]; then
                    # Docker Desktop socket - mount directly
                    DOCKER_OPTS+=(
                        -v "$SSH_SOCKET:/tmp/ssh-agent"
                        -e "SSH_AUTH_SOCK=/tmp/ssh-agent"
                    )
                else
                    # Regular socket (might not work with Docker Desktop)
                    echo "Warning: SSH agent forwarding may not work with Docker Desktop"
                    echo "Consider upgrading Docker Desktop to 4.24+ for built-in support"
                    DOCKER_OPTS+=(
                        -v "$SSH_SOCKET:/tmp/ssh-agent"
                        -e "SSH_AUTH_SOCK=/tmp/ssh-agent"
                    )
                fi
                ;;
            linux-gnu*)
                # Linux: Standard mounting
                DOCKER_OPTS+=(
                    -v "$SSH_SOCKET:/tmp/ssh-agent"
                    -e "SSH_AUTH_SOCK=/tmp/ssh-agent"
                )
                ;;
            *)
                # Other platforms: Attempt standard mounting
                DOCKER_OPTS+=(
                    -v "$SSH_SOCKET:/tmp/ssh-agent"
                    -e "SSH_AUTH_SOCK=/tmp/ssh-agent"
                )
                ;;
        esac
        
        [ "$DEBUG_MODE" = false ] && echo "SSH agent forwarding enabled"
    else
        echo "Warning: SSH agent not available or not running"
        echo "Git operations over SSH will not work. Start ssh-agent or use --no-ssh-agent to suppress this warning"
    fi
fi

# Ensure .claude directory and .claude.json exist
mkdir -p "$HOME/.claude" 2>/dev/null || true
[ -f "$HOME/.claude.json" ] || echo "{}" > "$HOME/.claude.json"

# Mount configuration directories and files
DOCKER_OPTS+=(
    -v "$HOME/.claude:/home/ubuntu/.claude:rw"
    -v "$HOME/.claude.json:/home/ubuntu/.claude.json:rw"
)

# Create a temporary directory for SSH with proper permissions
SSH_TEMP_DIR=$(mktemp -d -t claucker-ssh-XXXXXX)

# Copy SSH config files to temp directory with correct permissions
if [ -d "$HOME/.ssh" ]; then
    # Create SSH directory structure with correct permissions
    mkdir -p "$SSH_TEMP_DIR/.ssh"
    chmod 700 "$SSH_TEMP_DIR/.ssh"
    
    # Copy config and known_hosts if they exist
    if [ -f "$HOME/.ssh/config" ]; then
        cp "$HOME/.ssh/config" "$SSH_TEMP_DIR/.ssh/config"
        chmod 644 "$SSH_TEMP_DIR/.ssh/config"
    fi
    if [ -f "$HOME/.ssh/known_hosts" ]; then
        cp "$HOME/.ssh/known_hosts" "$SSH_TEMP_DIR/.ssh/known_hosts"
        chmod 644 "$SSH_TEMP_DIR/.ssh/known_hosts"
    fi
    
    # Mount the prepared SSH directory
    DOCKER_OPTS+=(-v "$SSH_TEMP_DIR/.ssh:/home/ubuntu/.ssh:rw")
fi

# Mount git config if it exists
[ -f "$HOME/.gitconfig" ] && DOCKER_OPTS+=(-v "$HOME/.gitconfig:/home/ubuntu/.gitconfig:ro")

# Mount project-level configuration if it exists
[ -d "$(pwd)/.claude" ] && DOCKER_OPTS+=(-v "$(pwd)/.claude:/workspace/$PROJECT_NAME/.claude:rw")
[ -f "$(pwd)/CLAUDE.md" ] && DOCKER_OPTS+=(-v "$(pwd)/CLAUDE.md:/workspace/$PROJECT_NAME/CLAUDE.md:ro")

# Build the claude command with or without --dangerously-skip-permissions
if [ "$USE_YOLO" = true ]; then
    CLAUDE_CMD="claude --dangerously-skip-permissions"
else
    CLAUDE_CMD="claude"
fi

# Run the container
if [ "$DEBUG_MODE" = true ]; then
    echo "Entering debug shell. Run 'claude' to test Claude Code, 'exit' to leave."
    if [ "$USE_YOLO" = true ]; then
        echo "YOLO mode enabled: claude will run with --dangerously-skip-permissions"
    fi
    echo ""
    docker run "${DOCKER_OPTS[@]}" "$IMAGE_NAME" /bin/bash
else
    docker run "${DOCKER_OPTS[@]}" "$IMAGE_NAME" $CLAUDE_CMD "${CLAUDE_ARGS[@]}"
fi
